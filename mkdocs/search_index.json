{
    "docs": [
        {
            "location": "/", 
            "text": "SAPHRON\n\uf0c1\n\n\nThanks for visiting the official documentation for SAPHRON \n(\nS\ntatistical \nA\npplied \nPH\nysics through \nR\nandomized \nO\nn-the-fly \nN\numerics), \na lightweight C++11-based Monte Carlo molecular simulation package. \nSAPHRON is currently \nunder development and may lack some basic features\n. As a result, the documentation may also \nnot be up-to-date. If you are feeling up to it, then please, dive right in!\n\n\nOverview\n\uf0c1\n\n\nThe primary goal of SAPHRON is to provide a simple, extensible and \nuser friendly\n API and \ninterface for carrying out Monte Carlo simulations. It is both a library and a standalone \napplication, with an emphasis on density of states (DOS) based sampling. A few key features \nare listed below.\n\n\n\n\nLattice simulations support (Ising, Lebwohl-Lasher, etc...)\n\n\nOff-lattice atomistic simulations.\n\n\nOpenMP parallelization.\n\n\nDOS sampling on various order parameters.\n\n\nNative JSON support for input files.\n\n\nExtensive suite of unit tests.\n\n\nClear user error reporting \n\n\n\n\nOne point of frustration for us using various molecular simulation packages was the lack \nof clear error reporting. We found that packages often dumped meaningless errors, sometimes\neven contradictory messages in response to semantic errors in input files. In a few cases, \napplications seg-faulted on syntax errors. \nThat is NOT okay!\n\n\nSAPHRON was designed to provide thoughtful, meaningful and helpful error messages to the user\nas a way of guiding them towards crafting a valid input file. As SAPHRON develops, this feature \nwill be built out to provide general notices and hints as well. Our hope is that SAPHRON will\nbe easy enough to use so that with a little bit of practice, it can be operated by a high-school \nstudent. If you feel any aspect of SAPHRON's usability can be improved, please let us know \nimmediately by \nopening a ticket\n.\n\n\nDependencies\n\uf0c1\n\n\nSAPHRON requires GCC 4.9.x or Clang 3.4+ \nat minimum\n. This is not an issue for most \nsystems, but if you are running Ubuntu 14.04 LTS, please read \n\nthis\n.\nSAPHRON also depends on \nArmadillo\n to provide an interface to \nlow level linear algebra routines. It links directly to any linear algebra provider \navailable on the system. BLAS and LAPACK are the default providers, but SAPHRON \nalso supports the Intel MKL. Typically, no configuration on the user's end is required. \nAll dependencies are automatically detected by the CMake build system. \n\n\nIf you just want to get things going, it is easy enough to install the required libraries.\nFor a Debian-based distro simply type:\n\n\n$ sudo apt-get install libblas3 liblapack3 libarmadillo-dev\n\n\n\n\nThis will install the BLAS/LAPACK shared libraries and Armadillo headers. As mentioned, \nif you have access to Intel's MKL you don't have to do anything else and SAPHRON should \nfind it. If the MKL is available via an environment module, it is recommended that it be \nloaded since it offers superior performance. Just make sure that wherever the binary is\ndeployed also has access.\n\n\nSAPHRON will NOT compile until you perform the next step!\n\nBy default, Armadillo assumes you want to link against its shared library. SAPHRON does not do this, \nbut instead links directly to BLAS and LAPACK or MKL as mentioned above. To fix this, use your editor \nof choice (here we use vim) to modify the Armadillo config header:\n\n\n$ vim /usr/include/armadillo_bits/config.hpp\n\n\n\n\nJust comment out the line that says \n#define ARMA_USE_WRAPPER\n and you're good to go!\n\n\nOpenMP\n\uf0c1\n\n\nSAPHRON uses OpenMP to parallelize energy evaluations, neighbor list generation and other \ncalculations. It relies on compilers that support the \n-fopenmp\n flag. OpenMP support is enabled\nby default. If you do not want to run SAPHRON multi-threaded, see the advanced configuration \nsection below.\n\n\nInstallation\n\uf0c1\n\n\nThe first step is to clone the repository locally\n\n\n$ git clone https://github.com/hsidky/SAPHRON.git\n\n\n\n\nSAPHRON uses a CMake build system. It is recommended that you perform an out of source build. \nTo do so, enter the following commands\n\n\n$ cd SAPHRON\n$ mkdir build \n cd build\n$ cmake .. \n$ make\n$ sudo make install\n\n\n\n\nThis will install a \nsaphron\n binary into \n/usr/local/bin\n and a static library in \n/usr/local/lib/libsaphron.a\n.\nNow that SAPHRON is installed, hop on over to the \nGetting Started\n page to\nset up and run your first simulation!\n\n\nAdvanced installation\n\uf0c1\n\n\nIf you do not have root access or would like to build SAPHRON for a cluster, it is possible \nto manually specify the location of the Armadillo headers by specifying the ARMA_PATHS variable\nin CMake\n\n\n$ cmake -DARMA_PATHS=/path/to/arma ..\n\n\n\n\nOpenMP support can also be disabled if desired\n\n\n$ cmake -DSAPHRON_OPENMP=false ..\n\n\n\n\nBy default, SAPHRON is built optimized without debug info, to change the build type to \ninclude debug info for debugging or profiling\n\n\n$ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n\n\n\n\nOf course, any of the default CMake variables are available and can be combined as desired.\n\n\nTesting\n\uf0c1\n\n\nSAPHRON has a comprehensive, but not \nexhaustive\n suite of unit tests. They range from \nsimple behavioral verification, to full fledged simulations verified against NIST data. \nThe \nGoogle C++ Testing Framework\n is used for \nunit testing. It is automatically downloaded as part of the build process. It is a good idea \nif deploying SAPHRON for the first time to run the unit tests. This can be done in the build \ndirectory by typing \n\n\n$ make test\n\n\n\n\nIt is also a great way to make sure that any customizations you make do not introduce new \nbugs into the code and to get a feel for the SAPHRON API.\n\n\nAcknowledgements\n\uf0c1\n\n\nSAPHRON\n utilizes the following packages: \n\n\nArmadillo (http://arma.sourceforge.net/)\n\n\nJSONCpp (https://github.com/open-source-parsers/jsoncpp)\n\n\nSitmo Random Number Generator (http://www.sitmo.com/article/multi-threaded-random-number-generation-in-c11/)\n\n\nSAPHRON\n would also not be possible without the support and expertise of \nEliseo Marin-Rimoldi\n, \ndeveloper of \nCassandra\n.\n\n\nContributing\n\uf0c1\n\n\nFeel free to fork this project on \nGitHub\n. Any pull-requests,\nfeature requests or other form of contributions are welcome. We especially encourage users to \nreport bugs or request features; you can guide the development of this project!", 
            "title": "Home"
        }, 
        {
            "location": "/#saphron", 
            "text": "Thanks for visiting the official documentation for SAPHRON \n( S tatistical  A pplied  PH ysics through  R andomized  O n-the-fly  N umerics), \na lightweight C++11-based Monte Carlo molecular simulation package.  SAPHRON is currently \nunder development and may lack some basic features . As a result, the documentation may also \nnot be up-to-date. If you are feeling up to it, then please, dive right in!", 
            "title": "SAPHRON"
        }, 
        {
            "location": "/#overview", 
            "text": "The primary goal of SAPHRON is to provide a simple, extensible and  user friendly  API and \ninterface for carrying out Monte Carlo simulations. It is both a library and a standalone \napplication, with an emphasis on density of states (DOS) based sampling. A few key features \nare listed below.   Lattice simulations support (Ising, Lebwohl-Lasher, etc...)  Off-lattice atomistic simulations.  OpenMP parallelization.  DOS sampling on various order parameters.  Native JSON support for input files.  Extensive suite of unit tests.  Clear user error reporting    One point of frustration for us using various molecular simulation packages was the lack \nof clear error reporting. We found that packages often dumped meaningless errors, sometimes\neven contradictory messages in response to semantic errors in input files. In a few cases, \napplications seg-faulted on syntax errors.  That is NOT okay!  SAPHRON was designed to provide thoughtful, meaningful and helpful error messages to the user\nas a way of guiding them towards crafting a valid input file. As SAPHRON develops, this feature \nwill be built out to provide general notices and hints as well. Our hope is that SAPHRON will\nbe easy enough to use so that with a little bit of practice, it can be operated by a high-school \nstudent. If you feel any aspect of SAPHRON's usability can be improved, please let us know \nimmediately by  opening a ticket .", 
            "title": "Overview"
        }, 
        {
            "location": "/#dependencies", 
            "text": "SAPHRON requires GCC 4.9.x or Clang 3.4+  at minimum . This is not an issue for most \nsystems, but if you are running Ubuntu 14.04 LTS, please read  this .\nSAPHRON also depends on  Armadillo  to provide an interface to \nlow level linear algebra routines. It links directly to any linear algebra provider \navailable on the system. BLAS and LAPACK are the default providers, but SAPHRON \nalso supports the Intel MKL. Typically, no configuration on the user's end is required. \nAll dependencies are automatically detected by the CMake build system.   If you just want to get things going, it is easy enough to install the required libraries.\nFor a Debian-based distro simply type:  $ sudo apt-get install libblas3 liblapack3 libarmadillo-dev  This will install the BLAS/LAPACK shared libraries and Armadillo headers. As mentioned, \nif you have access to Intel's MKL you don't have to do anything else and SAPHRON should \nfind it. If the MKL is available via an environment module, it is recommended that it be \nloaded since it offers superior performance. Just make sure that wherever the binary is\ndeployed also has access.  SAPHRON will NOT compile until you perform the next step! \nBy default, Armadillo assumes you want to link against its shared library. SAPHRON does not do this, \nbut instead links directly to BLAS and LAPACK or MKL as mentioned above. To fix this, use your editor \nof choice (here we use vim) to modify the Armadillo config header:  $ vim /usr/include/armadillo_bits/config.hpp  Just comment out the line that says  #define ARMA_USE_WRAPPER  and you're good to go!  OpenMP \uf0c1  SAPHRON uses OpenMP to parallelize energy evaluations, neighbor list generation and other \ncalculations. It relies on compilers that support the  -fopenmp  flag. OpenMP support is enabled\nby default. If you do not want to run SAPHRON multi-threaded, see the advanced configuration \nsection below.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#installation", 
            "text": "The first step is to clone the repository locally  $ git clone https://github.com/hsidky/SAPHRON.git  SAPHRON uses a CMake build system. It is recommended that you perform an out of source build. \nTo do so, enter the following commands  $ cd SAPHRON\n$ mkdir build   cd build\n$ cmake .. \n$ make\n$ sudo make install  This will install a  saphron  binary into  /usr/local/bin  and a static library in  /usr/local/lib/libsaphron.a .\nNow that SAPHRON is installed, hop on over to the  Getting Started  page to\nset up and run your first simulation!  Advanced installation \uf0c1  If you do not have root access or would like to build SAPHRON for a cluster, it is possible \nto manually specify the location of the Armadillo headers by specifying the ARMA_PATHS variable\nin CMake  $ cmake -DARMA_PATHS=/path/to/arma ..  OpenMP support can also be disabled if desired  $ cmake -DSAPHRON_OPENMP=false ..  By default, SAPHRON is built optimized without debug info, to change the build type to \ninclude debug info for debugging or profiling  $ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..  Of course, any of the default CMake variables are available and can be combined as desired.", 
            "title": "Installation"
        }, 
        {
            "location": "/#testing", 
            "text": "SAPHRON has a comprehensive, but not  exhaustive  suite of unit tests. They range from \nsimple behavioral verification, to full fledged simulations verified against NIST data. \nThe  Google C++ Testing Framework  is used for \nunit testing. It is automatically downloaded as part of the build process. It is a good idea \nif deploying SAPHRON for the first time to run the unit tests. This can be done in the build \ndirectory by typing   $ make test  It is also a great way to make sure that any customizations you make do not introduce new \nbugs into the code and to get a feel for the SAPHRON API.", 
            "title": "Testing"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "SAPHRON  utilizes the following packages:   Armadillo (http://arma.sourceforge.net/)  JSONCpp (https://github.com/open-source-parsers/jsoncpp)  Sitmo Random Number Generator (http://www.sitmo.com/article/multi-threaded-random-number-generation-in-c11/)  SAPHRON  would also not be possible without the support and expertise of  Eliseo Marin-Rimoldi , \ndeveloper of  Cassandra .", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/#contributing", 
            "text": "Feel free to fork this project on  GitHub . Any pull-requests,\nfeature requests or other form of contributions are welcome. We especially encourage users to \nreport bugs or request features; you can guide the development of this project!", 
            "title": "Contributing"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\uf0c1\n\n\nThe basics\n\uf0c1\n\n\nSAPHRON simulations can either be run using the API or using \nJSON\n input files.\nJSON is a lightweight text format which is easy for humans to read and write and for machines to \nparse and generate. Almost every programming language offers some level of JSON support, making it \nparticularly convenient to script or automate input file generation using, say, Python (more on that later).\nIf you've never used JSON before, don't worry. Throughout the documentation we make no assumptions about \nthe user's knowledge of JSON and provide clear easy-to-follow examples.\n\n\nThe SAPHRON executable has two modes: validation and execution. An input file's syntax can be verified \nby running SAPHRON with the \n-v\n flag. This is a great way to make sure there are no input file errors \nbefore submitting a job to a HPC cluster. A typical example of this is shown below.\n\n\n$ saphron -v \n input.json \n\n **********************************************************************      \n *         ____      _     ____   _   _  ____    ___   _   _          *      \n *        / ___|    / \\   |  _ \\ | | | ||  _ \\  / _ \\ | \\ | |         * \n *        \\___ \\   / _ \\  | |_) || |_| || |_) || | | ||  \\| |         *  \n *         ___) | / ___ \\ |  __/ |  _  ||  _ \n | |_| || |\\  |         *    \n *        |____/ /_/   \\_\\|_|    |_| |_||_| \\_\\ \\___/ |_| \\_|         *\n *                                                                    *      \n *   Statistical Applied PHysics through Random On-the-fly Numerics   *\n *                                                                    *     \n *  Version 0.0.7 Revision: a2fe4783e74ca5460c9825553a955b8835d4197b  *      \n **********************************************************************      \n\n \n Validating JSON...                                               OK!\n \n Building world(s)...                                             OK!\n * Building world \nworld0\n...\n * Setting size to [20.000000, 20.000000, 20.000000] \u212b.\n * Setting neighbor list radius to 5.000000 \u212b.\n * Setting skin thickness to 2.000000 \u212b.\n * Setting seed to 471762238.\n * Setting temperature to 1.500000K.\n * Initialized 3000 particle(s) of type \nLJ\n.\n \n Building forcefield(s)...                                        OK!\n * Initialized 1 forcefield(s).\n \n Building move(s)...                                              OK!\n * Initialized Translate move.\n \n Building observer(s)...                                          OK!\n * Initialized DLMFile observer.\n * Set sampling frequency to 1 sweeps.\n * Initialized XYZ observer.\n * Set sampling frequency to 1 sweeps.\n \n Building simulation...                                           OK!\n$ \n\n\n\n\nSAPHRON will provide a basic summary of the settings supplied in the input file. To actually run the \nsimulation, simply remove the \n-v\n flag, and off it goes. At the completion \nof a simulation, some general CPU usage statistics are provided to help the user optimize their \ninput files.\n\n\nA note on ensembles\n\uf0c1\n\n\nOne of the most important things to remember is that in SAPHRON, \nensembles are not \ndefined explicitly\n. To offer maximum flexibility, an ensemble is a consequence of the \nmoves specified by the user, not the other way around. Check the examples section for \nways of reproducing common ensembles in SAPHRON.\n\n\nJSON\n\uf0c1\n\n\nA SAPHRON input file is a valid JSON document. Here we will define a bit of terminology \nrelating to JSON. Take the following JSON structure as an example, obtained from \n\nWikipedia\n:\n\n\n{\n    \nfirstName\n: \nJohn\n,\n    \nlastName\n: \nSmith\n,\n    \nage\n: 25,\n    \naddress\n: {\n        \nstreetAddress\n: \n21 2nd Street\n,\n        \ncity\n: \nNew York\n,\n        \nstate\n: \nNY\n,\n        \npostalCode\n: \n10021\n\n    },\n    \nphoneNumber\n: [\n        {\n            \ntype\n: \nhome\n,\n            \nnumber\n: \n212 555-1234\n\n        },\n        {\n            \ntype\n: \nfax\n,\n            \nnumber\n: \n646 555-4567\n\n        }\n    ],\n    \ngender\n: {\n        \ntype\n: \nmale\n\n    }\n}\n\n\n\n\nThe first pair of curly brackets define the \nroot\n section, we will signify this using \n#\n.\nAn item in the hierarchy, such as the street address, can be referenced like this: \n\n#/address/streetAddress\n. \n\n\nBefore moving on to SAPHRON specific JSON, we'll mention a few more things about JSON.\n\n\n\n\n\n\nSquare brackets \n[]\n in JSON refer to \narrays\n, while curly brackets refer to \nobjects\n. \nThey can be thought of as Python lists and dictionaries respectively. That would make \n\n#/phoneNumber\n an array of phone number objects, each containing a type \nand a number. The fax number can be referenced by \n#/phoneNumber/1/number\n, where \n1\n is \nthe array index beginning from zero.\n\n\n\n\n\n\nItems in a JSON object (Python dictionary) are unique. In the example above, \n#/age\n can \nonly be defined once - it is a key in the root tree. Defining \n#/age\n again will not throw \nan error, but instead the last definition will override any previous definitions. This is \nactually very powerful behavior. It means a user can import a general forcefield for example \nand override whatever parameters they wish. The exact behavior of the merging process is \ndescribed in detail in the user guide.\n\n\n\n\n\n\nTypes matter in JSON. Notice how \n#/age\n is specified by a number that is not surrounded in\nquotes. This is a number, more specifically an integer. \n#/address/postalCode\n on the other \nhand is a string, even though the contents of the string are all numbers. Some fields in SAPHRON \nmay require the input to be a string, integer or number and the user should be aware of this difference.\n\n\n\n\n\n\nUnits\n\uf0c1\n\n\nSAPHRON supports both real and reduced units. For a detailed breakdown of the real units\nused in a simulation, check out the \nsimulation\n page in the \nuser guide.\n\n\nParticles\n\uf0c1\n\n\nA particle is a general object that can be manipulated in a simulation. Molecules, \natoms and spins are all \ntypes\n of particles. This abstraction is part of what gives \nthe SAPHRON engine its flexibility. Particles can also be thought of as composite \nobjects. They can have children, like a molecule, or be a \"primitive\", like an atom or \na spin. Currently, the SAPHRON input file supports one level of depth - basically \na molecule/atom hierarchy. \n\n\nThe structure of a particle is defined by its topology, or \nblueprint\n. A blueprint is nothing \nbut a description of a particle's topology. For something simple, like a spin or Lennard-Jones\nparticle, it would look like this: \n\n\nblueprints\n : {\n    \nLJ\n : {\n        \nmasss\n : 1.0,\n        \ncharge\n : 0.0\n    }\n}\n\n\n\n\nThe above example shows an neutral unit LJ particle. To introduce a bit of terminology: \"LJ\" is \nthe \nspecies\n name of the particle. A more complex topology, like that of SPCE water would be\n\n\nblueprints\n : {\n    \nH2O\n : {\n        \nchildren\n : [\n            {\n                \nspecies\n : \nO\n,\n                \ncharge\n : -0.84760,\n                \nmass\n : 15.9994\n            },\n            {\n                \nspecies\n: \nH1\n,\n                \ncharge\n : 0.42380,\n                \nmass\n : 1.00794\n            },\n            {\n                \nspecies\n: \nH2\n,\n                \ncharge\n : 0.42380, \n                \nmass\n : 1.00794\n            }\n        ]\n    }\n\n\n\n\nLet's go through this in detail: we have defined a particle of type \"H2O\" (which is a molecule), with \nthree children defined in an array. Each child has a species, charge and mass specified. A few things \nstand out. The first is that we have not defined any bonds, bends or positions of the water molecule. \nIn SAPHRON particles are rigid by default; this includes molecules. Since SPCE is a rigid model, \nwe do not need to specify any bonds or bends. Specifying bonds are used for evaluating bonded interactions. \n\n\n\n\nNote\n\n\nSAPHRON does not yet support flexible (nearest)-neighbor interaction scaling/exclusion. The default\nbehavior is to exclude all nonbonded interactions for bonded pairs. Nonbonded interactions are \nevaluated for all non-bonded pairs within a molecule.\n\n\n\n\nThe internal coordinates within the H2O molecule are also not specified. When specifying a world (see below), \nthe coordinates of primitive particles, in this case atoms, are defined in the system (think XYZ file). \nThis is done since flexible molecules may have different configurations. In a sense, \"H2O\" can \nbe thought of as a container for three atoms. That means non-primitive particles cannot have a defined \ncharge, mass or position. The three quantities are calculated properties from the children.\n\n\nWorlds\n\uf0c1\n\n\nA simulation box is called a \"world\" in SAPHRON. An arbitrary number of worlds are supported, each containing \nan arbitrary number of particles. Along with containing particles, a world also has properties, some specified \nand some calculated. Since a world is responsible for providing a move with a random particle, the user can define \na seed for the random number generator. User defined properties of a world include dimensions, temperature, and\nthe chemical potential of species within the world. This means that different worlds can have different temperatures \nand species chemical potentials, allowing for some very creative \"ensembles\". Calculated properties include \npressure, energy, dimensions (in non-constant volume ensembles) and in some cases chemical potential.\n\n\nThere are two other important properties that required for a world: neighbor list cutoff and skin thickness.\nEach forcefield is responsible for specifying its cutoff radii (they can be vary between worlds), but the \nworld is responsible for generating the neighbor lists for its particles. The neighbor list cutoff in a world\nshould be equal to or exceed the largest specified forcefield cutoff radius, \"rcmax\". Another subtle point is the \nskin thickness. This value should be chosen to be, \nat maximum\n the difference between \"rcmax\" and the neighbor \nlist cutoff. Make the value any smaller and you run the risk of excluding particles from an energy calculation \nthat should be included. However, this is not guaranteed since it is of a stochastic nature. These rules are \nnot enforced by SAPHRON to offer the user the flexibility for those who like to live on the edge!\n\n\nUsing the LJ blueprint from above, we define a world with 300 LJ atoms\n\n\nworlds\n : [\n    {\n        \ntype\n : \nSimple\n,\n        \ndimensions\n : [10, 10, 10],\n        \nseed\n : 300, \n        \nnlist_cutoff\n : 3.5,\n        \nskin_thickness\n: 0.5,\n        \ncomponents\n : [\n            [\nLJ\n, 100]\n        ], \n        \nparticles\n : [\n            [1, \nLJ\n, [4.881841346822,6.371867327468,4.106571184116]],\n            [2, \nLJ\n, [2.530762553678,3.610971102018,5.829908319858]],\n            [3, \nLJ\n, [1.947804017482,6.637837197361,9.390609698797]],\n            [4, \nLJ\n, [9.765735290537,8.258298245790,7.792001193077]],\n            [5, \nLJ\n, [3.097831629217,9.321038282277,9.453535007431]],\n            ...\n        ]\n    }\n]\n\n\n\n\nNotice how we've defined a world type. For now \"Simple\" is the only option, which represents an orthorhombic \nbox, but non-orthorhombic geometry support is coming soon. `#/worlds/0/components' defines the number of each \nhigh level\n \nspecies in the box. In this case, LJ is both the high level type and primitive. Under '#/worlds/0/particles' a unique ID \nis given to each primitive particle, the species is defined and finally the coordinates are given. For SPCE water this \nwould look like\n\n\nworlds\n : [\n    {\n        \ntype\n: \nSimple\n,\n        \ndimensions\n: [20, 20, 20],\n        \nseed\n: 300,\n        \nnlist_cutoff\n: 10.0,\n        \nskin_thickness\n : 0,\n        \ncomponents\n : [\n            [\nH2O\n, 100]\n        ],\n        \nparticles\n : [\n            [1, \nO\n, [4.7730209484199992, 1.5620128626400014, 1.5253242702800005]],\n            [2, \nH1\n, [4.0459440059599991, 0.9341800149600008, 1.8031462188700003]],\n            [3, \nH2\n, [5.1428368446299997, 1.2737801963600006, 0.6420586630000003]],\n            [4, \nO\n, [8.0901735057700002, 4.5440428079500004, 1.2051669896099995]],\n            [5, \nH1\n, [8.7068419886699999, 5.2474487816600011, 0.8516984360500004]],\n            [6, \nH2\n, [7.8721620900899989, 3.8950436691600006, 0.4762835006500001]],\n            ...\n        ]\n    }\n]\n\n\n\n\nHere the number of H2O molecules is specified and the coordinates of each atom is given under \n#/worlds/0/particles\n. \nSince there are 100 H2O molecules, SAPHRON would expect 300 atoms in the order in which they appear in the blueprint. \nMore options are available for a world and individual particle directors can also be specified. Details are available \nin the \nuser guide\n. There are additional options to pack a world with particles. \n\n\nObservers\n\uf0c1\n\n\nObservers are objects that \"observe\" a simulation as it proceeds and take notes. In other words, observers can be \nthought of as loggers. SAPHRON offers a number of different observers, including a JSON observer which writes \ncheckpoint JSON files, a general delimited file observer which writes various properties and an XYZ observer which \nwrites snapshots of worlds to XYZ files. There can be an arbitrary number of observers logging different \nproperties at independent frequencies. An example is shown below\n\n\nobservers\n : [\n    {\n        \ntype\n : \nDLMFile\n,\n        \nfrequency\n : 1,\n        \nprefix\n : \ntest\n,\n        \nflags\n : {\n            \nsimulation\n : 1,\n            \nworld\n : 1\n        }\n    },\n    {\n        \ntype\n : \nJSON\n,\n        \nfrequency\n : 1000,\n        \nprefix\n : \ntest_checkpt\n\n    },\n    {\n        \ntype\n : \nXYZ\n, \n        \nfrequency\n : 100,\n        \nprefix\n : \ntest_xyz\n\n    }\n]\n\n\n\n\nWe've defined three different observers above. The first is a fixed-width space delimited logger recording \nsimulation and world properties every iteration. The second is a JSON observer writing checkpoint files every \n1000 iterations. The third is an XYZ observer recording snapshots every 100 iterations. Note the \nprefix\n\nspecification which is used for the file names. Also, multiple observers of the same type can be defined to \nlog the same or different properties independent of one another. A detailed list of options and flags is located \nin the \nuser guide\n.\n\n\nInput file structure\n\uf0c1\n\n\nA SAPHRON input file consists of a collection of JSON objects and arrays. The main \nsections are outlined below:\n\n\n\n\n#\n - The JSON root encompasses everything and defines an entire simulation.\n\n\n#/worlds\n - Array defining the different \"worlds\", or boxes, in the system.\n\n\n#/moves\n - Array defining the moves to be performed on the worlds.\n\n\n#/forcefields\n - Array defining the bonded, nonbonded and electrostatic interactions.\n\n\n#/blueprints\n - Object containing the blueprints, or topologies, of the particles in the simulation.\n\n\n#/observers\n - Array defining all of the observers, or loggers, that will collect data throughout the simulation.\n\n\n#/DOS\n - Object containing settings for DOS simulations. \n\n\n#/Histogram\n - Object containing settings for histograms.\n\n\n\n\nAn empty shell containing some of the above looks like this:\n\n\n{\n    \nblueprints\n : {\n\n    },\n    \nforcefields\n : {\n        \nnonbonded\n : [\n        ],\n        \nbonded\n : [\n        ],\n        \nelectrostatic\n : [\n        ]\n    },\n    \nworlds\n : [\n    ],\n    \nmoves\n : [\n    ],\n    \nobservers\n : [\n    ]\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#the-basics", 
            "text": "SAPHRON simulations can either be run using the API or using  JSON  input files.\nJSON is a lightweight text format which is easy for humans to read and write and for machines to \nparse and generate. Almost every programming language offers some level of JSON support, making it \nparticularly convenient to script or automate input file generation using, say, Python (more on that later).\nIf you've never used JSON before, don't worry. Throughout the documentation we make no assumptions about \nthe user's knowledge of JSON and provide clear easy-to-follow examples.  The SAPHRON executable has two modes: validation and execution. An input file's syntax can be verified \nby running SAPHRON with the  -v  flag. This is a great way to make sure there are no input file errors \nbefore submitting a job to a HPC cluster. A typical example of this is shown below.  $ saphron -v   input.json \n\n **********************************************************************      \n *         ____      _     ____   _   _  ____    ___   _   _          *      \n *        / ___|    / \\   |  _ \\ | | | ||  _ \\  / _ \\ | \\ | |         * \n *        \\___ \\   / _ \\  | |_) || |_| || |_) || | | ||  \\| |         *  \n *         ___) | / ___ \\ |  __/ |  _  ||  _   | |_| || |\\  |         *    \n *        |____/ /_/   \\_\\|_|    |_| |_||_| \\_\\ \\___/ |_| \\_|         *\n *                                                                    *      \n *   Statistical Applied PHysics through Random On-the-fly Numerics   *\n *                                                                    *     \n *  Version 0.0.7 Revision: a2fe4783e74ca5460c9825553a955b8835d4197b  *      \n **********************************************************************      \n\n   Validating JSON...                                               OK!\n   Building world(s)...                                             OK!\n * Building world  world0 ...\n * Setting size to [20.000000, 20.000000, 20.000000] \u212b.\n * Setting neighbor list radius to 5.000000 \u212b.\n * Setting skin thickness to 2.000000 \u212b.\n * Setting seed to 471762238.\n * Setting temperature to 1.500000K.\n * Initialized 3000 particle(s) of type  LJ .\n   Building forcefield(s)...                                        OK!\n * Initialized 1 forcefield(s).\n   Building move(s)...                                              OK!\n * Initialized Translate move.\n   Building observer(s)...                                          OK!\n * Initialized DLMFile observer.\n * Set sampling frequency to 1 sweeps.\n * Initialized XYZ observer.\n * Set sampling frequency to 1 sweeps.\n   Building simulation...                                           OK!\n$   SAPHRON will provide a basic summary of the settings supplied in the input file. To actually run the \nsimulation, simply remove the  -v  flag, and off it goes. At the completion \nof a simulation, some general CPU usage statistics are provided to help the user optimize their \ninput files.  A note on ensembles \uf0c1  One of the most important things to remember is that in SAPHRON,  ensembles are not \ndefined explicitly . To offer maximum flexibility, an ensemble is a consequence of the \nmoves specified by the user, not the other way around. Check the examples section for \nways of reproducing common ensembles in SAPHRON.", 
            "title": "The basics"
        }, 
        {
            "location": "/getting-started/#json", 
            "text": "A SAPHRON input file is a valid JSON document. Here we will define a bit of terminology \nrelating to JSON. Take the following JSON structure as an example, obtained from  Wikipedia :  {\n     firstName :  John ,\n     lastName :  Smith ,\n     age : 25,\n     address : {\n         streetAddress :  21 2nd Street ,\n         city :  New York ,\n         state :  NY ,\n         postalCode :  10021 \n    },\n     phoneNumber : [\n        {\n             type :  home ,\n             number :  212 555-1234 \n        },\n        {\n             type :  fax ,\n             number :  646 555-4567 \n        }\n    ],\n     gender : {\n         type :  male \n    }\n}  The first pair of curly brackets define the  root  section, we will signify this using  # .\nAn item in the hierarchy, such as the street address, can be referenced like this:  #/address/streetAddress .   Before moving on to SAPHRON specific JSON, we'll mention a few more things about JSON.    Square brackets  []  in JSON refer to  arrays , while curly brackets refer to  objects . \nThey can be thought of as Python lists and dictionaries respectively. That would make  #/phoneNumber  an array of phone number objects, each containing a type \nand a number. The fax number can be referenced by  #/phoneNumber/1/number , where  1  is \nthe array index beginning from zero.    Items in a JSON object (Python dictionary) are unique. In the example above,  #/age  can \nonly be defined once - it is a key in the root tree. Defining  #/age  again will not throw \nan error, but instead the last definition will override any previous definitions. This is \nactually very powerful behavior. It means a user can import a general forcefield for example \nand override whatever parameters they wish. The exact behavior of the merging process is \ndescribed in detail in the user guide.    Types matter in JSON. Notice how  #/age  is specified by a number that is not surrounded in\nquotes. This is a number, more specifically an integer.  #/address/postalCode  on the other \nhand is a string, even though the contents of the string are all numbers. Some fields in SAPHRON \nmay require the input to be a string, integer or number and the user should be aware of this difference.", 
            "title": "JSON"
        }, 
        {
            "location": "/getting-started/#units", 
            "text": "SAPHRON supports both real and reduced units. For a detailed breakdown of the real units\nused in a simulation, check out the  simulation  page in the \nuser guide.", 
            "title": "Units"
        }, 
        {
            "location": "/getting-started/#particles", 
            "text": "A particle is a general object that can be manipulated in a simulation. Molecules, \natoms and spins are all  types  of particles. This abstraction is part of what gives \nthe SAPHRON engine its flexibility. Particles can also be thought of as composite \nobjects. They can have children, like a molecule, or be a \"primitive\", like an atom or \na spin. Currently, the SAPHRON input file supports one level of depth - basically \na molecule/atom hierarchy.   The structure of a particle is defined by its topology, or  blueprint . A blueprint is nothing \nbut a description of a particle's topology. For something simple, like a spin or Lennard-Jones\nparticle, it would look like this:   blueprints  : {\n     LJ  : {\n         masss  : 1.0,\n         charge  : 0.0\n    }\n}  The above example shows an neutral unit LJ particle. To introduce a bit of terminology: \"LJ\" is \nthe  species  name of the particle. A more complex topology, like that of SPCE water would be  blueprints  : {\n     H2O  : {\n         children  : [\n            {\n                 species  :  O ,\n                 charge  : -0.84760,\n                 mass  : 15.9994\n            },\n            {\n                 species :  H1 ,\n                 charge  : 0.42380,\n                 mass  : 1.00794\n            },\n            {\n                 species :  H2 ,\n                 charge  : 0.42380, \n                 mass  : 1.00794\n            }\n        ]\n    }  Let's go through this in detail: we have defined a particle of type \"H2O\" (which is a molecule), with \nthree children defined in an array. Each child has a species, charge and mass specified. A few things \nstand out. The first is that we have not defined any bonds, bends or positions of the water molecule. \nIn SAPHRON particles are rigid by default; this includes molecules. Since SPCE is a rigid model, \nwe do not need to specify any bonds or bends. Specifying bonds are used for evaluating bonded interactions.    Note  SAPHRON does not yet support flexible (nearest)-neighbor interaction scaling/exclusion. The default\nbehavior is to exclude all nonbonded interactions for bonded pairs. Nonbonded interactions are \nevaluated for all non-bonded pairs within a molecule.   The internal coordinates within the H2O molecule are also not specified. When specifying a world (see below), \nthe coordinates of primitive particles, in this case atoms, are defined in the system (think XYZ file). \nThis is done since flexible molecules may have different configurations. In a sense, \"H2O\" can \nbe thought of as a container for three atoms. That means non-primitive particles cannot have a defined \ncharge, mass or position. The three quantities are calculated properties from the children.", 
            "title": "Particles"
        }, 
        {
            "location": "/getting-started/#worlds", 
            "text": "A simulation box is called a \"world\" in SAPHRON. An arbitrary number of worlds are supported, each containing \nan arbitrary number of particles. Along with containing particles, a world also has properties, some specified \nand some calculated. Since a world is responsible for providing a move with a random particle, the user can define \na seed for the random number generator. User defined properties of a world include dimensions, temperature, and\nthe chemical potential of species within the world. This means that different worlds can have different temperatures \nand species chemical potentials, allowing for some very creative \"ensembles\". Calculated properties include \npressure, energy, dimensions (in non-constant volume ensembles) and in some cases chemical potential.  There are two other important properties that required for a world: neighbor list cutoff and skin thickness.\nEach forcefield is responsible for specifying its cutoff radii (they can be vary between worlds), but the \nworld is responsible for generating the neighbor lists for its particles. The neighbor list cutoff in a world\nshould be equal to or exceed the largest specified forcefield cutoff radius, \"rcmax\". Another subtle point is the \nskin thickness. This value should be chosen to be,  at maximum  the difference between \"rcmax\" and the neighbor \nlist cutoff. Make the value any smaller and you run the risk of excluding particles from an energy calculation \nthat should be included. However, this is not guaranteed since it is of a stochastic nature. These rules are \nnot enforced by SAPHRON to offer the user the flexibility for those who like to live on the edge!  Using the LJ blueprint from above, we define a world with 300 LJ atoms  worlds  : [\n    {\n         type  :  Simple ,\n         dimensions  : [10, 10, 10],\n         seed  : 300, \n         nlist_cutoff  : 3.5,\n         skin_thickness : 0.5,\n         components  : [\n            [ LJ , 100]\n        ], \n         particles  : [\n            [1,  LJ , [4.881841346822,6.371867327468,4.106571184116]],\n            [2,  LJ , [2.530762553678,3.610971102018,5.829908319858]],\n            [3,  LJ , [1.947804017482,6.637837197361,9.390609698797]],\n            [4,  LJ , [9.765735290537,8.258298245790,7.792001193077]],\n            [5,  LJ , [3.097831629217,9.321038282277,9.453535007431]],\n            ...\n        ]\n    }\n]  Notice how we've defined a world type. For now \"Simple\" is the only option, which represents an orthorhombic \nbox, but non-orthorhombic geometry support is coming soon. `#/worlds/0/components' defines the number of each  high level  \nspecies in the box. In this case, LJ is both the high level type and primitive. Under '#/worlds/0/particles' a unique ID \nis given to each primitive particle, the species is defined and finally the coordinates are given. For SPCE water this \nwould look like  worlds  : [\n    {\n         type :  Simple ,\n         dimensions : [20, 20, 20],\n         seed : 300,\n         nlist_cutoff : 10.0,\n         skin_thickness  : 0,\n         components  : [\n            [ H2O , 100]\n        ],\n         particles  : [\n            [1,  O , [4.7730209484199992, 1.5620128626400014, 1.5253242702800005]],\n            [2,  H1 , [4.0459440059599991, 0.9341800149600008, 1.8031462188700003]],\n            [3,  H2 , [5.1428368446299997, 1.2737801963600006, 0.6420586630000003]],\n            [4,  O , [8.0901735057700002, 4.5440428079500004, 1.2051669896099995]],\n            [5,  H1 , [8.7068419886699999, 5.2474487816600011, 0.8516984360500004]],\n            [6,  H2 , [7.8721620900899989, 3.8950436691600006, 0.4762835006500001]],\n            ...\n        ]\n    }\n]  Here the number of H2O molecules is specified and the coordinates of each atom is given under  #/worlds/0/particles . \nSince there are 100 H2O molecules, SAPHRON would expect 300 atoms in the order in which they appear in the blueprint. \nMore options are available for a world and individual particle directors can also be specified. Details are available \nin the  user guide . There are additional options to pack a world with particles.", 
            "title": "Worlds"
        }, 
        {
            "location": "/getting-started/#observers", 
            "text": "Observers are objects that \"observe\" a simulation as it proceeds and take notes. In other words, observers can be \nthought of as loggers. SAPHRON offers a number of different observers, including a JSON observer which writes \ncheckpoint JSON files, a general delimited file observer which writes various properties and an XYZ observer which \nwrites snapshots of worlds to XYZ files. There can be an arbitrary number of observers logging different \nproperties at independent frequencies. An example is shown below  observers  : [\n    {\n         type  :  DLMFile ,\n         frequency  : 1,\n         prefix  :  test ,\n         flags  : {\n             simulation  : 1,\n             world  : 1\n        }\n    },\n    {\n         type  :  JSON ,\n         frequency  : 1000,\n         prefix  :  test_checkpt \n    },\n    {\n         type  :  XYZ , \n         frequency  : 100,\n         prefix  :  test_xyz \n    }\n]  We've defined three different observers above. The first is a fixed-width space delimited logger recording \nsimulation and world properties every iteration. The second is a JSON observer writing checkpoint files every \n1000 iterations. The third is an XYZ observer recording snapshots every 100 iterations. Note the  prefix \nspecification which is used for the file names. Also, multiple observers of the same type can be defined to \nlog the same or different properties independent of one another. A detailed list of options and flags is located \nin the  user guide .", 
            "title": "Observers"
        }, 
        {
            "location": "/getting-started/#input-file-structure", 
            "text": "A SAPHRON input file consists of a collection of JSON objects and arrays. The main \nsections are outlined below:   #  - The JSON root encompasses everything and defines an entire simulation.  #/worlds  - Array defining the different \"worlds\", or boxes, in the system.  #/moves  - Array defining the moves to be performed on the worlds.  #/forcefields  - Array defining the bonded, nonbonded and electrostatic interactions.  #/blueprints  - Object containing the blueprints, or topologies, of the particles in the simulation.  #/observers  - Array defining all of the observers, or loggers, that will collect data throughout the simulation.  #/DOS  - Object containing settings for DOS simulations.   #/Histogram  - Object containing settings for histograms.   An empty shell containing some of the above looks like this:  {\n     blueprints  : {\n\n    },\n     forcefields  : {\n         nonbonded  : [\n        ],\n         bonded  : [\n        ],\n         electrostatic  : [\n        ]\n    },\n     worlds  : [\n    ],\n     moves  : [\n    ],\n     observers  : [\n    ]\n}", 
            "title": "Input file structure"
        }, 
        {
            "location": "/examples/canonical-simulations/", 
            "text": "ss", 
            "title": "Canonical simulations"
        }, 
        {
            "location": "/user-guide/simulation/", 
            "text": "", 
            "title": "Simulation"
        }, 
        {
            "location": "/user-guide/blueprints/", 
            "text": "", 
            "title": "Blueprints"
        }, 
        {
            "location": "/user-guide/worlds/", 
            "text": "", 
            "title": "Worlds"
        }, 
        {
            "location": "/user-guide/forcefields/", 
            "text": "", 
            "title": "Forcefields"
        }, 
        {
            "location": "/user-guide/moves/", 
            "text": "", 
            "title": "Moves"
        }, 
        {
            "location": "/user-guide/observers/", 
            "text": "", 
            "title": "Observers"
        }, 
        {
            "location": "/user-guide/density-of-states/", 
            "text": "", 
            "title": "Density of states"
        }, 
        {
            "location": "/user-guide/histogram/", 
            "text": "", 
            "title": "Histogram"
        }
    ]
}