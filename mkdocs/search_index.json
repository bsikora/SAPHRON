{
    "docs": [
        {
            "location": "/", 
            "text": "SAPHRON\n\uf0c1\n\n\nThanks for visiting the official documentation for SAPHRON \n(\nS\ntatistical \nA\npplied \nPH\nysics through \nR\nandomized \nO\nn-the-fly \nN\numerics), \na lightweight C++11-based Monte Carlo molecular simulation package. \nSAPHRON is currently \nunder development and may lack some basic features\n. As a result, the documentation may also \nnot be up-to-date. If you are feeling up to it, then please, dive right in!\n\n\nOverview\n\uf0c1\n\n\nThe primary goal of SAPHRON is to provide a simple, extensible and \nuser friendly\n API and \ninterface for carrying out Monte Carlo simulations. It is both a library and a standalone \napplication, with an emphasis on density of states (DOS) based sampling. A few key features \nare listed below.\n\n\n\n\nLattice simulations support (Ising, Lebwohl-Lasher, etc...)\n\n\nOff-lattice atomistic simulations.\n\n\nOpenMP parallelization.\n\n\nDOS sampling on various order parameters.\n\n\nNative JSON support for input files.\n\n\nExtensive suite of unit tests.\n\n\nClear user error reporting \n\n\n\n\nOne point of frustration for us using various molecular simulation packages was the lack \nof clear error reporting. We found that packages often dumped meaningless errors, sometimes\neven contradictory messages in response to semantic errors in input files. In a few cases, \napplications seg-faulted on syntax errors. \nThat is NOT okay!\n\n\nSAPHRON was designed to provide thoughtful, meaningful and helpful error messages to the user\nas a way of guiding them towards crafting a valid input file. As SAPHRON develops, this feature \nwill be built out to provide general notices and hints as well. Our hope is that SAPHRON will\nbe easy enough to use so that with a little bit of practice, it can be operated by a high-school \nstudent. If you feel any aspect of SAPHRON's usability can be improved, please let us know \nimmediately by \nopening a ticket\n.\n\n\nDependencies\n\uf0c1\n\n\nSAPHRON requires GCC 4.9.x or Clang 3.4+ \nat minimum\n. This is not an issue for most \nsystems, but if you are running Ubuntu 14.04 LTS, please read \n\nthis\n.\nSAPHRON also depends on \nArmadillo\n to provide an interface to \nlow level linear algebra routines. It links directly to any linear algebra provider \navailable on the system. BLAS and LAPACK are the default providers, but SAPHRON \nalso supports the Intel MKL. Typically, no configuration on the user's end is required. \nAll dependencies are automatically detected by the CMake build system. \n\n\nIf you just want to get things going, it is easy enough to install the required libraries.\nFor a Debian-based distro simply type:\n\n\n$ sudo apt-get install libblas3 liblapack3 libarmadillo-dev\n\n\n\n\nThis will install the BLAS/LAPACK shared libraries and Armadillo headers. As mentioned, \nif you have access to Intel's MKL you don't have to do anything else and SAPHRON should \nfind it. If the MKL is available via an environment module, it is recommended that it be \nloaded since it offers superior performance. Just make sure that wherever the binary is\ndeployed also has access.\n\n\nSAPHRON will NOT compile until you perform the next step!\n\nBy default, Armadillo assumes you want to link against its shared library. SAPHRON does not do this, \nbut instead links directly to BLAS and LAPACK or MKL as mentioned above. To fix this, use your editor \nof choice (here we use vim) to modify the Armadillo config header:\n\n\n$ vim /usr/include/armadillo_bits/config.hpp\n\n\n\n\nJust comment out the line that says \n#define ARMA_USE_WRAPPER\n and you're good to go!\n\n\nOpenMP\n\uf0c1\n\n\nSAPHRON uses OpenMP to parallelize energy evaluations, neighbor list generation and other \ncalculations. It relies on compilers that support the \n-fopenmp\n flag. OpenMP support is enabled\nby default. If you do not want to run SAPHRON multi-threaded, see the advanced configuration \nsection below.\n\n\nInstallation\n\uf0c1\n\n\nThe first step is to clone the repository locally\n\n\n$ git clone https://github.com/hsidky/SAPHRON.git\n\n\n\n\nSAPHRON uses a CMake build system. It is recommended that you perform an out of source build. \nTo do so, enter the following commands\n\n\n$ cd SAPHRON\n$ mkdir build \n cd build\n$ cmake .. \n$ make\n$ sudo make install\n\n\n\n\nThis will install a \nsaphron\n binary into \n/usr/local/bin\n and a static library in \n/usr/local/lib/libsaphron.a\n.\nNow that SAPHRON is installed, hop on over to the \nGetting Started\n page to\nset up and run your first simulation!\n\n\nAdvanced installation\n\uf0c1\n\n\nIf you do not have root access or would like to build SAPHRON for a cluster, it is possible \nto manually specify the location of the Armadillo headers by specifying the ARMA_PATHS variable\nin CMake\n\n\n$ cmake -DARMA_PATHS=/path/to/arma ..\n\n\n\n\nOpenMP support can also be disabled if desired\n\n\n$ cmake -DSAPHRON_OPENMP=false ..\n\n\n\n\nBy default, SAPHRON is built optimized without debug info, to change the build type to \ninclude debug info for debugging or profiling\n\n\n$ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n\n\n\n\nOf course, any of the default CMake variables are available and can be combined as desired.\n\n\nTesting\n\uf0c1\n\n\nSAPHRON has a comprehensive, but not \nexhaustive\n suite of unit tests. They range from \nsimple behavioral verification, to full fledged simulations verified against NIST data. \nThe \nGoogle C++ Testing Framework\n is used for \nunit testing. It is automatically downloaded as part of the build process. It is a good idea \nif deploying SAPHRON for the first time to run the unit tests. This can be done in the build \ndirectory by typing \n\n\n$ make test\n\n\n\n\nIt is also a great way to make sure that any customizations you make do not introduce new \nbugs into the code and to get a feel for the SAPHRON API.\n\n\nAcknowledgements\n\uf0c1\n\n\nSAPHRON\n utilizes the following packages: \n\n\nArmadillo (http://arma.sourceforge.net/)\n\n\nJSONCpp (https://github.com/open-source-parsers/jsoncpp)\n\n\nSitmo Random Number Generator (http://www.sitmo.com/article/multi-threaded-random-number-generation-in-c11/)\n\n\nSAPHRON\n would also not be possible without the support and expertise of \nEliseo Marin-Rimoldi\n, \ndeveloper of \nCassandra\n.\n\n\nContributing\n\uf0c1\n\n\nFeel free to fork this project on \nGitHub\n. Any pull-requests,\nfeature requests or other form of contributions are welcome.", 
            "title": "Home"
        }, 
        {
            "location": "/#saphron", 
            "text": "Thanks for visiting the official documentation for SAPHRON \n( S tatistical  A pplied  PH ysics through  R andomized  O n-the-fly  N umerics), \na lightweight C++11-based Monte Carlo molecular simulation package.  SAPHRON is currently \nunder development and may lack some basic features . As a result, the documentation may also \nnot be up-to-date. If you are feeling up to it, then please, dive right in!", 
            "title": "SAPHRON"
        }, 
        {
            "location": "/#overview", 
            "text": "The primary goal of SAPHRON is to provide a simple, extensible and  user friendly  API and \ninterface for carrying out Monte Carlo simulations. It is both a library and a standalone \napplication, with an emphasis on density of states (DOS) based sampling. A few key features \nare listed below.   Lattice simulations support (Ising, Lebwohl-Lasher, etc...)  Off-lattice atomistic simulations.  OpenMP parallelization.  DOS sampling on various order parameters.  Native JSON support for input files.  Extensive suite of unit tests.  Clear user error reporting    One point of frustration for us using various molecular simulation packages was the lack \nof clear error reporting. We found that packages often dumped meaningless errors, sometimes\neven contradictory messages in response to semantic errors in input files. In a few cases, \napplications seg-faulted on syntax errors.  That is NOT okay!  SAPHRON was designed to provide thoughtful, meaningful and helpful error messages to the user\nas a way of guiding them towards crafting a valid input file. As SAPHRON develops, this feature \nwill be built out to provide general notices and hints as well. Our hope is that SAPHRON will\nbe easy enough to use so that with a little bit of practice, it can be operated by a high-school \nstudent. If you feel any aspect of SAPHRON's usability can be improved, please let us know \nimmediately by  opening a ticket .", 
            "title": "Overview"
        }, 
        {
            "location": "/#dependencies", 
            "text": "SAPHRON requires GCC 4.9.x or Clang 3.4+  at minimum . This is not an issue for most \nsystems, but if you are running Ubuntu 14.04 LTS, please read  this .\nSAPHRON also depends on  Armadillo  to provide an interface to \nlow level linear algebra routines. It links directly to any linear algebra provider \navailable on the system. BLAS and LAPACK are the default providers, but SAPHRON \nalso supports the Intel MKL. Typically, no configuration on the user's end is required. \nAll dependencies are automatically detected by the CMake build system.   If you just want to get things going, it is easy enough to install the required libraries.\nFor a Debian-based distro simply type:  $ sudo apt-get install libblas3 liblapack3 libarmadillo-dev  This will install the BLAS/LAPACK shared libraries and Armadillo headers. As mentioned, \nif you have access to Intel's MKL you don't have to do anything else and SAPHRON should \nfind it. If the MKL is available via an environment module, it is recommended that it be \nloaded since it offers superior performance. Just make sure that wherever the binary is\ndeployed also has access.  SAPHRON will NOT compile until you perform the next step! \nBy default, Armadillo assumes you want to link against its shared library. SAPHRON does not do this, \nbut instead links directly to BLAS and LAPACK or MKL as mentioned above. To fix this, use your editor \nof choice (here we use vim) to modify the Armadillo config header:  $ vim /usr/include/armadillo_bits/config.hpp  Just comment out the line that says  #define ARMA_USE_WRAPPER  and you're good to go!  OpenMP \uf0c1  SAPHRON uses OpenMP to parallelize energy evaluations, neighbor list generation and other \ncalculations. It relies on compilers that support the  -fopenmp  flag. OpenMP support is enabled\nby default. If you do not want to run SAPHRON multi-threaded, see the advanced configuration \nsection below.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#installation", 
            "text": "The first step is to clone the repository locally  $ git clone https://github.com/hsidky/SAPHRON.git  SAPHRON uses a CMake build system. It is recommended that you perform an out of source build. \nTo do so, enter the following commands  $ cd SAPHRON\n$ mkdir build   cd build\n$ cmake .. \n$ make\n$ sudo make install  This will install a  saphron  binary into  /usr/local/bin  and a static library in  /usr/local/lib/libsaphron.a .\nNow that SAPHRON is installed, hop on over to the  Getting Started  page to\nset up and run your first simulation!  Advanced installation \uf0c1  If you do not have root access or would like to build SAPHRON for a cluster, it is possible \nto manually specify the location of the Armadillo headers by specifying the ARMA_PATHS variable\nin CMake  $ cmake -DARMA_PATHS=/path/to/arma ..  OpenMP support can also be disabled if desired  $ cmake -DSAPHRON_OPENMP=false ..  By default, SAPHRON is built optimized without debug info, to change the build type to \ninclude debug info for debugging or profiling  $ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..  Of course, any of the default CMake variables are available and can be combined as desired.", 
            "title": "Installation"
        }, 
        {
            "location": "/#testing", 
            "text": "SAPHRON has a comprehensive, but not  exhaustive  suite of unit tests. They range from \nsimple behavioral verification, to full fledged simulations verified against NIST data. \nThe  Google C++ Testing Framework  is used for \nunit testing. It is automatically downloaded as part of the build process. It is a good idea \nif deploying SAPHRON for the first time to run the unit tests. This can be done in the build \ndirectory by typing   $ make test  It is also a great way to make sure that any customizations you make do not introduce new \nbugs into the code and to get a feel for the SAPHRON API.", 
            "title": "Testing"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "SAPHRON  utilizes the following packages:   Armadillo (http://arma.sourceforge.net/)  JSONCpp (https://github.com/open-source-parsers/jsoncpp)  Sitmo Random Number Generator (http://www.sitmo.com/article/multi-threaded-random-number-generation-in-c11/)  SAPHRON  would also not be possible without the support and expertise of  Eliseo Marin-Rimoldi , \ndeveloper of  Cassandra .", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/#contributing", 
            "text": "Feel free to fork this project on  GitHub . Any pull-requests,\nfeature requests or other form of contributions are welcome.", 
            "title": "Contributing"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\uf0c1\n\n\nThe basics\n\uf0c1\n\n\nSAPHRON simulations can either be run using the API or using \nJSON\n input files.\nJSON is a lightweight text format which is easy for humans to read and write and for machines to \nparse and generate. Almost every programming language offers some level of JSON support, making it \nparticularly convenient to script or automate input file generation using, say, Python (more on that later).\nIf you've never used JSON before, don't worry. Throughout the documentation we make no assumptions about \nthe user's knowledge of JSON and provide clear easy-to-follow examples.\n\n\nThe SAPHRON executable has two modes: validation and execution. An input file's syntax can be verified \nby running SAPHRON with the \n-v\n flag. This is a great way to make sure there are no input file errors \nbefore submitting a job to a HPC cluster. A typical example of this is shown below.\n\n\n$ saphron -v \n input.json \n\n **********************************************************************      \n *         ____      _     ____   _   _  ____    ___   _   _          *      \n *        / ___|    / \\   |  _ \\ | | | ||  _ \\  / _ \\ | \\ | |         * \n *        \\___ \\   / _ \\  | |_) || |_| || |_) || | | ||  \\| |         *  \n *         ___) | / ___ \\ |  __/ |  _  ||  _ \n | |_| || |\\  |         *    \n *        |____/ /_/   \\_\\|_|    |_| |_||_| \\_\\ \\___/ |_| \\_|         *\n *                                                                    *      \n *   Statistical Applied PHysics through Random On-the-fly Numerics   *\n *                                                                    *     \n *  Version 0.0.7 Revision: a2fe4783e74ca5460c9825553a955b8835d4197b  *      \n **********************************************************************      \n\n \n Validating JSON...                                               OK!\n \n Building world(s)...                                             OK!\n * Building world \nworld0\n...\n * Setting size to [20.000000, 20.000000, 20.000000] \u212b.\n * Setting neighbor list radius to 5.000000 \u212b.\n * Setting skin thickness to 2.000000 \u212b.\n * Setting seed to 471762238.\n * Setting temperature to 1.500000K.\n * Initialized 3000 particle(s) of type \nLJ\n.\n \n Building forcefield(s)...                                        OK!\n * Initialized 1 forcefield(s).\n \n Building move(s)...                                              OK!\n * Initialized Translate move.\n \n Building observer(s)...                                          OK!\n * Initialized DLMFile observer.\n * Set sampling frequency to 1 sweeps.\n * Initialized XYZ observer.\n * Set sampling frequency to 1 sweeps.\n \n Building simulation...                                           OK!\n$ \n\n\n\n\nSAPHRON will provide a basic summary of the settings supplied in the input file. To actually run the \nsimulation, simply remove the \n-v\n flag, and off it goes. At the completion \nof a simulation, some general CPU usage statistics are provided to help the user optimize their \ninput files.\n\n\nA note on ensembles\n\uf0c1\n\n\nOne of the most important things to remember is that in SAPHRON, \nensembles are not \ndefined explicitly\n. To offer maximum flexibility, an ensemble is a consequence of the \nmoves specified by the user, not the other way around. Check the examples section for \nways of reproducing common ensembles in SAPHRON.\n\n\nConcepts\n\uf0c1\n\n\nTo better understand the documentation, we describe a few key concepts used in SAPHRON\nwhich may not be immediately obvious to the user.\n\n\nParticles\n\uf0c1\n\n\nWorlds\n\uf0c1\n\n\nObservers\n\uf0c1\n\n\nBlueprints\n\uf0c1\n\n\nJSON\n\uf0c1\n\n\nA SAPHRON input file is a valid JSON document. Here we will define a bit of terminology \nrelating to JSON. Take the following JSON structure as an example, obtained from \n\nWikipedia\n:\n\n\n{\n    \nfirstName\n: \nJohn\n,\n    \nlastName\n: \nSmith\n,\n    \nage\n: 25,\n    \naddress\n: {\n        \nstreetAddress\n: \n21 2nd Street\n,\n        \ncity\n: \nNew York\n,\n        \nstate\n: \nNY\n,\n        \npostalCode\n: \n10021\n\n    },\n    \nphoneNumber\n: [\n        {\n            \ntype\n: \nhome\n,\n            \nnumber\n: \n212 555-1234\n\n        },\n        {\n            \ntype\n: \nfax\n,\n            \nnumber\n: \n646 555-4567\n\n        }\n    ],\n    \ngender\n: {\n        \ntype\n: \nmale\n\n    }\n}\n\n\n\n\nThe first pair of curly brackets define the \nroot\n section, we will signify this using \n#\n.\nAn item in the hierarchy, such as the street address, can be referenced like this: \n\n#/address/streetAddress\n. Before moving on to SAPHRON specific JSON, it is important \nto recognize that square brackets \n[]\n in JSON refer to \narrays\n, while curly brackets\nrefer to \nobjects\n. They can be thought of as Python lists and dictionaries respectively. \nThat would make \n#/phoneNumber\n an array of phone number objects, each containing a type \nand a number. The fax number can be referenced by \n#/phoneNumber/1/number\n, where \n1\n is \nthe array index beginning from zero.\n\n\nInput file structure\n\uf0c1\n\n\nA SAPHRON input file consists of a collection of JSON objects and arrays. The main \nsections are outlined below:\n\n\n\n\n#\n - The JSON root encompasses everything and defines an entire simulation.\n\n\n#/worlds\n - Array defining the different \"worlds\", or boxes, in the system.\n\n\n#/moves\n - Array defining the moves to be performed on the worlds.\n\n\n#/forcefields\n - Array defining the bonded, nonbonded and electrostatic interactions.\n\n\n#/blueprints\n - Object containing the blueprints, or topologies, of the particles in the simulation.\n\n\n#/observers\n - Array defining all of the observers, or loggers, that will collect data throughout the simulation.\n\n\n#/DOS\n - Object containing settings for DOS simulations. \n\n\n#/Histogram\n - Object containing settings for histograms.\n\n\n\n\nAn empty shell containing some of the above looks like this:\n\n\n{\n    \nblueprints\n : {\n\n    },\n    \nforcefields\n : {\n        \nnonbonded\n : [\n        ],\n        \nbonded\n : [\n        ],\n        \nelectrostatic\n : [\n        ]\n    },\n    \nworlds\n : [\n    ],\n    \nmoves\n : [\n    ],\n    \nobservers\n : [\n    ]\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#the-basics", 
            "text": "SAPHRON simulations can either be run using the API or using  JSON  input files.\nJSON is a lightweight text format which is easy for humans to read and write and for machines to \nparse and generate. Almost every programming language offers some level of JSON support, making it \nparticularly convenient to script or automate input file generation using, say, Python (more on that later).\nIf you've never used JSON before, don't worry. Throughout the documentation we make no assumptions about \nthe user's knowledge of JSON and provide clear easy-to-follow examples.  The SAPHRON executable has two modes: validation and execution. An input file's syntax can be verified \nby running SAPHRON with the  -v  flag. This is a great way to make sure there are no input file errors \nbefore submitting a job to a HPC cluster. A typical example of this is shown below.  $ saphron -v   input.json \n\n **********************************************************************      \n *         ____      _     ____   _   _  ____    ___   _   _          *      \n *        / ___|    / \\   |  _ \\ | | | ||  _ \\  / _ \\ | \\ | |         * \n *        \\___ \\   / _ \\  | |_) || |_| || |_) || | | ||  \\| |         *  \n *         ___) | / ___ \\ |  __/ |  _  ||  _   | |_| || |\\  |         *    \n *        |____/ /_/   \\_\\|_|    |_| |_||_| \\_\\ \\___/ |_| \\_|         *\n *                                                                    *      \n *   Statistical Applied PHysics through Random On-the-fly Numerics   *\n *                                                                    *     \n *  Version 0.0.7 Revision: a2fe4783e74ca5460c9825553a955b8835d4197b  *      \n **********************************************************************      \n\n   Validating JSON...                                               OK!\n   Building world(s)...                                             OK!\n * Building world  world0 ...\n * Setting size to [20.000000, 20.000000, 20.000000] \u212b.\n * Setting neighbor list radius to 5.000000 \u212b.\n * Setting skin thickness to 2.000000 \u212b.\n * Setting seed to 471762238.\n * Setting temperature to 1.500000K.\n * Initialized 3000 particle(s) of type  LJ .\n   Building forcefield(s)...                                        OK!\n * Initialized 1 forcefield(s).\n   Building move(s)...                                              OK!\n * Initialized Translate move.\n   Building observer(s)...                                          OK!\n * Initialized DLMFile observer.\n * Set sampling frequency to 1 sweeps.\n * Initialized XYZ observer.\n * Set sampling frequency to 1 sweeps.\n   Building simulation...                                           OK!\n$   SAPHRON will provide a basic summary of the settings supplied in the input file. To actually run the \nsimulation, simply remove the  -v  flag, and off it goes. At the completion \nof a simulation, some general CPU usage statistics are provided to help the user optimize their \ninput files.  A note on ensembles \uf0c1  One of the most important things to remember is that in SAPHRON,  ensembles are not \ndefined explicitly . To offer maximum flexibility, an ensemble is a consequence of the \nmoves specified by the user, not the other way around. Check the examples section for \nways of reproducing common ensembles in SAPHRON.", 
            "title": "The basics"
        }, 
        {
            "location": "/getting-started/#concepts", 
            "text": "To better understand the documentation, we describe a few key concepts used in SAPHRON\nwhich may not be immediately obvious to the user.  Particles \uf0c1  Worlds \uf0c1  Observers \uf0c1  Blueprints \uf0c1", 
            "title": "Concepts"
        }, 
        {
            "location": "/getting-started/#json", 
            "text": "A SAPHRON input file is a valid JSON document. Here we will define a bit of terminology \nrelating to JSON. Take the following JSON structure as an example, obtained from  Wikipedia :  {\n     firstName :  John ,\n     lastName :  Smith ,\n     age : 25,\n     address : {\n         streetAddress :  21 2nd Street ,\n         city :  New York ,\n         state :  NY ,\n         postalCode :  10021 \n    },\n     phoneNumber : [\n        {\n             type :  home ,\n             number :  212 555-1234 \n        },\n        {\n             type :  fax ,\n             number :  646 555-4567 \n        }\n    ],\n     gender : {\n         type :  male \n    }\n}  The first pair of curly brackets define the  root  section, we will signify this using  # .\nAn item in the hierarchy, such as the street address, can be referenced like this:  #/address/streetAddress . Before moving on to SAPHRON specific JSON, it is important \nto recognize that square brackets  []  in JSON refer to  arrays , while curly brackets\nrefer to  objects . They can be thought of as Python lists and dictionaries respectively. \nThat would make  #/phoneNumber  an array of phone number objects, each containing a type \nand a number. The fax number can be referenced by  #/phoneNumber/1/number , where  1  is \nthe array index beginning from zero.", 
            "title": "JSON"
        }, 
        {
            "location": "/getting-started/#input-file-structure", 
            "text": "A SAPHRON input file consists of a collection of JSON objects and arrays. The main \nsections are outlined below:   #  - The JSON root encompasses everything and defines an entire simulation.  #/worlds  - Array defining the different \"worlds\", or boxes, in the system.  #/moves  - Array defining the moves to be performed on the worlds.  #/forcefields  - Array defining the bonded, nonbonded and electrostatic interactions.  #/blueprints  - Object containing the blueprints, or topologies, of the particles in the simulation.  #/observers  - Array defining all of the observers, or loggers, that will collect data throughout the simulation.  #/DOS  - Object containing settings for DOS simulations.   #/Histogram  - Object containing settings for histograms.   An empty shell containing some of the above looks like this:  {\n     blueprints  : {\n\n    },\n     forcefields  : {\n         nonbonded  : [\n        ],\n         bonded  : [\n        ],\n         electrostatic  : [\n        ]\n    },\n     worlds  : [\n    ],\n     moves  : [\n    ],\n     observers  : [\n    ]\n}", 
            "title": "Input file structure"
        }, 
        {
            "location": "/examples/canonical-simulations/", 
            "text": "ss", 
            "title": "Canonical simulations"
        }, 
        {
            "location": "/user-guide/simulation/", 
            "text": "", 
            "title": "Simulation"
        }, 
        {
            "location": "/user-guide/blueprints/", 
            "text": "", 
            "title": "Blueprints"
        }, 
        {
            "location": "/user-guide/worlds/", 
            "text": "", 
            "title": "Worlds"
        }, 
        {
            "location": "/user-guide/forcefields/", 
            "text": "", 
            "title": "Forcefields"
        }, 
        {
            "location": "/user-guide/moves/", 
            "text": "", 
            "title": "Moves"
        }, 
        {
            "location": "/user-guide/observers/", 
            "text": "", 
            "title": "Observers"
        }, 
        {
            "location": "/user-guide/density-of-states/", 
            "text": "", 
            "title": "Density of states"
        }, 
        {
            "location": "/user-guide/histogram/", 
            "text": "", 
            "title": "Histogram"
        }
    ]
}